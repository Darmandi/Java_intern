<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Collections. Lite</title>
</head>

<body>
<h1>Collections. Lite</h1>
<nav>
    <ol>
        <li><a href="#1">Что такое “коллекция”?</a></li>
        <li><a href="#2">Назовите преимущества использования коллекций.</a></li>
        <li><a href="#3">Какие данные могут хранить коллекции?</a></li>
        <li><a href="#4">Какие есть типы коллекций? Как они характеризуются?</a></li>
        <li><a href="#5">Назовите основные реализации List, Set, Map.</a></li>
        <li><a href="#6">В чём отличие ArrayList от LinkedList?</a></li>
        <li><a href="#7">В чём отличие HashSet от TreeSet?</a></li>
        <li><a href="#8">В чём отличие Set от Map?</a></li>
        <li><a href="#9">Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?</a></li>
        <li><a href="#10">Чем отличается Comparable от Comparator?</a></li>
        <li><a href="#11">Что такое сортировка по принципу Natural Order?</a></li>
        <li><a href="#12">Что такое equals и hashcode?</a></li>
        <li><a href="#13">Какие есть способы перебора всех элементов List?</a></li>
        <li><a href="#14">Как реализован цикл foreach?</a></li>
        <li><a href="#15">В чем разница между Iterator и ListIterator?</a></li>
        <li><a href="#16">Как происходит удаление элементов из ArrayList?</a></li>
        <li><a href="#17">Как происходит удаление элементов из LinkedList?</a></li>

    </ol>
</nav>
<div id="1">
    <h3>Что такое “коллекция”?</h3>
    <p>Коллекциями/контейнерами в Java принято называть классы, основная цель которых – хранить набор других элементов.</p>
</div>
<div id="2">
    <h3>Назовите преимущества использования коллекций.</h3>
    <p>Массивы обладают значительными недостатками. Одним из них является конечный размер массива, как следствие, необходимость следить за размером массива. Другим — индексная адресация, что не всегда удобно, т.к. ограничивает возможности добавления и удаления объектов. Чтобы избавиться от этих недостатков уже несколько десятилетий программисты используют рекурсивные типы данных, такие как списки и деревья. Стандартный набор коллекций Java служит для избавления программиста от необходимости самостоятельно реализовывать эти типы данных и снабжает его дополнительными возможностями. Улучшается производительность, благодаря использованию высокоэффективных алгоритмов и структур данных
        Коллекции являются универсальным способом хранения и передачи данных, что упрощает взаимодействие разных частей кода
        Простота в изучении, потому что необходимо выучить только самые верхние интерфейсы и поддерживаемые операции</p>
</div>
<div id="3">
    <h3>Какие данные могут хранить коллекции?</h3>
    <p>Коллекции могут хранить любые ссылочные типы данных.</p>
</div>
<div id="4">
    <h3>Какие есть типы коллекций? Как они характеризуются?</h3>
    <img src="images/Collections.png" />
    <img src="images/Map.png" />
    <p><strong>List&#8249T&#8250</strong> — это упорядоченный список. Объекты хранятся в порядке их добавления в список. Доступ к элементам списка осуществляется по индексу.<br>
        Интерфейс <strong>List&#8249T&#8250</strong> является одним из наиболее часто используемых интерфейсов коллекций, который обозначает упорядоченную коллекцию. Каждый элемент списка имеет целочисленный индекс; возможно добавление и удаление элементов по индексу. Дополнительно этот интерфейс предоставляет специальный итератор ListIterator&#8249T&#8250, который позволяет перемещаться по списку в обе стороны и вставлять новые элементы.
    <ul>
        <li> Данный интерфейс предоставляет следующие методы: <strong>get(), indexOf(), lastIndexOf(), listIterator(), set(), subList()</strong>.</li>
        <li> Абстрактный класс AbstractList наследуется от AbstractCollection и реализует большинство методов List интерфейса.</li>
        <li>  Абстрактный класс AbstractSequentialList наследуется от AbstractList и реализует большинство методов List интерфейса с упором на последовательный, чем на случайный доступ к элементам.</li>
    </ul>
    <strong>Set&#8249T&#8250</strong> — множество неповторяющихся объектов. В коллекции этого типа разрешено наличие только одной ссылки типа null.<br>
    Интерфейс <strong>Set&#8249T&#8250</strong> предоставляет абстракцию математического множества, т.е. неупорядоченную коллекцию, не содержащую одинаковых элементов. Из-за неупорядоченности элементы множества нельзя получить по их индексу, поэтому для множеств не имеет смысла сортировка и перемешивание элементов. Однако при этом операции проверки на наличие элемента во множестве эффективнее, чем в списке.
    <ul>
        <li> Данный интерфейс предоставляет следующие методы: <strong>isEmpty()</strong>.</li>
        <li> Абстрактный класс AbstractSet наследуется от AbstractCollection и реализует большинство методов Set интерфейса.</li>
    </ul><br>
    Интерфейс <strong>SortedSet&#8249T&#8250</strong> является расширением Set&#8249T&#8250. Он предполагает наличие отношения порядка на своих элементах. Из-за этого SortedSet предоставляет дополнительные операции.
    <ul>
        <li> Данный интерфейс предоставляет следующие методы: <strong>clone(), comparator(), first(), headSet(), last(), subSet(), tailSet()</strong>.</li>
    </ul><br>
        <strong>Queue&#8249T&#8250</strong> — коллекция, предназначенная для хранения элементов в порядке, нужном для их обработки. В дополнение к базовым операциям интерфейса Collection, очередь предоставляет дополнительные операции вставки, получения и контроля.
        <br>Очереди обычно, но не обязательно, упорядочивают элементы в FIFO (first-in-first-out, «первым вошел — первым вышел») порядке.
    <ul>
        <li> Абстрактный класс AbstractQueue наследуется от AbstractCollection и реализует большинство методов Queue интерфейса.</li>
        <li> Данный интерфейс предоставляет следующие методы: <strong>offer(), peek(), poll()</strong>.</li>
    </ul>
    Интерфейс <strong>Deque&#8249T&#8250</strong> обозначает дек, структуру данных, являющуюся одновременно стеком и очередью. В дек можно добавлять и удалять элементы с двух сторон.
    <ul>
        <li> Данный интерфейс предоставляет следующие методы: <strong>offer(), peek(), poll(), addFirst(), addLast(), descendingIterator(), element(), getFirst(), getLast(), offerFirst(), offerLast(), peekFirst(), peekLast(), pollFirst(), pollLast(), pop(), push(), removeFirst(), removeFirstOccurrence(), removeLast(), removeLastOccurrence()`, size()</strong>.</li>
        <li>Метод offer() вставляет элемент в очередь, если это не удалось — возвращает false. Этот метод отличается от метода add() интерфейса Collection тем, что метод add() может неудачно добавить элемент только с использованием unchecked исключения.</li>
        <li>Методы remove() и poll() удаляют верхушку очереди и возвращают ее. Какой элемент будет удален (первый или последний) зависит от реализации очереди. Методы remove() и poll() отличаются лишь поведением, когда очередь пустая: метод remove() генерирует исключение, а метод poll() возвращает null.</li>
        <li>Методы element() и peek() возвращают (но не удаляют) верхушку очереди.</li>
    </ul>
        <strong>Map&#8249K, V&#8250</strong>  - используется для отображения каждого элемента из одного множества объектов (ключей) на другое (значений). При этом, каждому элементу из множества ключей ставится в соответствие одно значение из множества значений. В то же время одному элементу из множества значений может соответствовать 1, 2 и более элементов из множества ключей. Интерфейс java.util.Map&#8249K, V&#8250 описывает функциональность ассоциативных массивов.
    <ul>
        <li>Абстрактный класс AbstractMap реализует большинство методов Map интерфейса.</li>
        <li>Данный интерфейс предоставляет следующие методы: <strong>clear(), containsKey(), containsValue(), entrySet(), equals(), get(), hashCode(), isEmpty(), keySet(), put(), putAll(), remove(), size(), values()</strong>.</li>
    </ul>
    Интерфейс <strong>SortedMap&#8249K, V&#8250</strong> обозначает словарь, в котором на ключах задано отношение порядка. Аналогично SortedSet&#8249T&#8250, SortedMap&#8249K, V&#8250 предоставляет дополнительные операции. Предполагается, что эти операции словарь способен выполнять эффективно.
    <ul>
        <li>Данный интерфейс предоставляет следующие методы: <strong>comparator(), firstKey(), headMap(), lastKey(), subMap(), tailMap()</strong>.</li>
    </ul>
    </p>
</div>
<div id="5">
    <h3>Назовите основные реализации List, Set,Queue, Map.</h3>
    <table border="1" class="table_example">
        <tbody>
        <tr>
            <th width="30%">Интерфейс</th>
            <th width="35%">Класс/Реализация</th>
            <th width="35%">Описание</th>
        </tr>
        <tr class="blue_text">
            <td rowspan="4">List</td>
            <td>ArrayList</td>
            <td>Список</td>
        </tr>
        <tr class="blue_text">
            <td>LinkedList</td>
            <td>Список</td>
        </tr>
        <tr class="blue_text">
            <td>Vector</td>
            <td>Вектор (устарел)</td>
        </tr>
        <tr class="blue_text">
            <td>Stack</td>
            <td>Стек (устарел)</td>
        </tr>

        <tr class="green_text">
            <td rowspan="3">Set</td>
            <td>HashSet</td>
            <td>Множество</td>
        </tr>
        <tr class="green_text">
            <td>LinkedHashSet</td>
            <td>Множество</td>
        </tr>
        <tr class="green_text">
            <td>TreeSet</td>
            <td>Отсортированное множество</td>
        </tr>

        <tr class="red_text">
            <td rowspan="1">Queue</td>
            <td>ArrayDeque</td>
            <td>Очередь</td>
        </tr>

        <tr class="orange_text">
            <td rowspan="4">Map</td>
            <td>HashMap</td>
            <td>Карта/Словарь</td>
        </tr>
        <tr class="orange_text">
            <td>LinkedHashMap</td>
            <td>Карта/Словарь</td>
        </tr>
        <tr class="orange_text">
            <td>TreeMap</td>
            <td>Отсортированный словарь</td>
        </tr>
        <tr class="orange_text">
            <td>Hashtable</td>
            <td>Хеш-таблица (устарела)</td>
        </tr>
        </tbody>
    </table><br>
    <p>
    Реализация <strong>ArrayList&#8249T&#8250</strong> используется чаще всего в интерфейсе List. По сути является реализацией списка на основе массива. Кроме того, ArrayList очень эффективно использует память, и операции, основанные на доступе по индексу (сортировка, перемешивание, бинарный поиск и т.д.), выполняются быстро.
    <br>
        <ul>
            <li>Данная реализация предоставляет следующие методы: <strong>ensureCapacity(), removeRange(), trimToSize(), clone()</strong>.</li>
        </ul>
    Реализация <strong>LinkedList&#8249T&#8250</strong> используется гораздо реже. Является реализацией списка на основе двусвязного списка. LinkedList эффективнее при вставке/удалении элементов в начале или конце и при вставке/удалении в середине после итерации до нужного места. Также LinkedList потребляет значительно больше памяти, чем ArrayList.
        <ul>
            <li>Данная реализация предоставляет следующие методы: <strong>addFirst(), addLast(), clone(), getFirst(), getLast(), removeFirst(), removeLast()</strong>.</li>
        </ul>

    Реализация <strong>HashSet&#8249T&#8250</strong> — это наиболее часто используемая реализация множества, потому что основные задачи множества она выполняет наиболее эффективно. HashSet основан на HashMap. Поэтому, в частности, для использования HashSet необходима правильная реализация методов equals() и hashCode().
        <ul>
            <li>Данная реализация наследуется от AbstractSet.</li>
            <li>Данная реализация предоставляет следующие методы: <strong>clone()</strong>.</li>
        </ul>
    Реализация <strong>LinkedHashSet&#8249T&#8250</strong> объединяет множество на основе хеш-таблицы и связный список. Эффективность всех операций на нём та же, что и у HashSet, но порядок итерации по нему не псевдослучаен, а соответствует порядку добавления элементов в это множество. LinkedHashSet основан на LinkedHashMap и наследует HashSet, поэтому для него также справедливы условия на методы equals() и hashCode() у элементов.
        <ul>
            <li>Данная реализация наследуется от HashSet.</li>
        </ul>
    Реализация <strong>TreeSet&#8249T&#8250</strong> — это множество, основанное на TreeMap. Оно реализует интерфейс SortedSet&#8249T&#8250, и в нём могут храниться только элементы, на которых задано отношение порядка. Класс TreeSet основан на TreeMap, и поэтому все операции над элементами имеют логарифмическую сложность. Это хуже, чем у HashSet, поэтому TreeSet используется только тогда, когда необходимо так или иначе сортировать элементы множества.
        <ul>
            <li>Данная реализация наследуется от AbstractSet.</li>
            <li>Данная реализация предоставляет следующие методы: <strong>clone(), comparator(), first(), last(), headSet(), subSet(), tailSet()</strong>.</li>
        </ul>
    Реализация <strong>ArrayDeque&#8249T&#8250</strong> с помощью массива - наиболее удобная и эффективная.
        <ul>
            <li>Данная реализация наследуется от AbstractCollection и реализует интерфейс Deque.</li>
            <li>Данный интерфейс предоставляет следующие методы: <strong>isEmpty(), clone(), toArray()</strong>.</li>
        </ul>

    Реализация <strong>HashMap&#8249K, V&#8250</strong> - словарь на основе хеш-таблицы. Из-за этого все операции над HashMap очень эффективны. HashMap реализован как хеш-таблица на основе цепочек. Внутри он содержит массив «корзин», каждая из которых является односвязным списком. Поэтому элементы словаря должны корректно реализовывать методы equals() и hashCode(). Для идеальной хеш-функции эффективность операций константная.
    <ul>
        <li>Данная реализация наследуется от AbstractMap и реализует Map интерфейс.</li>
        <li>Данная реализация предоставляет следующие методы: <strong>clone()</strong>.</li>
        </ul>
    Реализация <strong>LinkedHashMap&#8249K, V&#8250</strong> объединяет хеш-таблицу и связный список. Используется, когда необходимо сохранять порядок добавления элементов в словарь. Помимо структуры хеш-таблицы, LinkedHashMap добавляет новые записи в связный список. С помощью этого можно восстановить порядок добавления элементов. Эффективность операций у LinkedHashMap та же, что и у обычного HashMap, но из-за дополнительной структуры на элементах потребление памяти выше.
        <ul>
            <li>Данная реализация наследуется от HashMap и реализует Map интерфейс.</li>
            <li>Данная реализация предоставляет следующие методы: <strong>removeEldestEntry()</strong>.</li>
        </ul>
    Реализация <strong>TreeMap&#8249K, V&#8250</strong> — это реализация словаря на основе красно-чёрного бинарного дерева поиска (дерево образуют ключи). Эта структура требует отношения порядка на элементах, поэтому TreeMap реализует интерфейс SortedMap. Поскольку внутри TreeMap используется бинарное дерево, то все операции имеют логарифмическую эффективность.
        <ul>
            <li>Данная реализация наследуется от AbstractMap и реализует SortedMap интерфейс.</li>
            <li>Данная реализация предоставляет следующие методы: <strong>clone()</strong>.</li>
        </ul>
    </p>
</div>
<div id="6">
    <h3>В чём отличие ArrayList от LinkedList?</h3>
    <p><strong>ArrayList</strong> реализован внутри в виде обычного массива. Поэтому при вставке элемента в середину, приходится сначала сдвигать на один все элементы после него, а уже затем в освободившееся место вставлять новый элемент. Зато в нем быстро реализованы взятие и изменение элемента – операции get, set, так как в них мы просто обращаемся к соответствующему элементу массива.
    <br><strong>LinkedList</strong> реализован внутри по-другому. Он реализован в виде связного списка: набора отдельных элементов, каждый из которых хранит ссылку на следующий и предыдущий элементы. Чтобы вставить элемент в середину такого списка, достаточно поменять ссылки его будущих соседей. А вот чтобы получить элемент с номером 130, нужно пройтись последовательно по всем объектам от 0 до 130. Другими словами операции set и get тут реализованы очень медленно.
    </p>
</div>
<div id="7">
    <h3>В чём отличие HashSet от TreeSet?</h3>
    <p>
        <strong>HashSet</strong> гораздо быстрее чем <strong>TreeSet</strong> (константное время против логарифмического для большинства операций, таких как add, remove, contains), но TreeSet гарантирует упорядоченность объектов. Оба не синхронизированы.
        <br><br>
        HashSet
        <ul>
        <li>предоставляет константное время для add(), remove(), contains() и size()</li>
        <li>порядок элементов в контейнере может меняться</li>
        <li>производительность итерации по контейнеру зависит от емкости и «коэффициента загрузки» (рекомендуется оставлять load factor значением по умолчанию равным 0.75, что является хорошим компромиссом между временем доступа и объемом хранимых данных)</li>
        </ul>
    TreeSet
        <ul>
            <li>время для базовых операций add(), remove(), contains() — log(n)</li>
            <li>гарантирует порядок элементов</li>
            <li>не предоставляет каких-либо параметров для настройки производительности</li>
            <li>предоставляет дополнительные методы для упорядоченного списка: first(), last(), headSet(), tailSet() и т.д.</li>
        </ul>
    </p>
</div>
<div id="8">
    <h3>В чём отличие Set от Map?</h3>
    <p>Map — коллекция пар ключ/значение, тогда как Set это коллекция уникальных элементов.</p>
</div>
<div id="9">
    <h3>Как задается порядок следования объектов в коллекции, как отсортировать коллекцию?</h3>
    <p>
    Класс ТгееМар полностью реализует интерфейс SortedMap. Он реализован как бинарное дерево поиска, значит его элементы хранятся в упорядоченном виде. Это  значительно ускоряет поиск нужного элемента. Порядок задается либо естественным следованием элементов, либо объектом, реализующим интерфейс сравнения Comparator.
        <br>В этом классе четыре конструктора:
    <ul>
    <li><strong>TreeМар()</strong> — создает пустой объект с естественным  порядком элементов</li>
    <li><strong>TreeМар(Comparator с)</strong> — создает пустой объект, в котором порядок задается объектом сравнения с</li>
    <li><strong>TreeМар(Map f)</strong> — создает объект, содержащий все элементы отображения f, с естественным порядком его элементов</li>
    <li><strong>TreeМар(SortedMap sf)</strong> — создает объект, содержащий все элементы отображения sf, в том же порядке</li>
    </ul>
    Интерфейс Comparator описывает два метода сравнения:
    <ul>
        <li><strong>int compare(Object obj1, object obj2)</strong> — возвращает отрицательное число, если obj1 в каком-то смысле меньше obj2; нуль, если они считаются равными; положительное число, если obj1 больше obj2.</li>
        <li><strong>boolean equals(Object obj)</strong> — сравнивает данный объект с объектом obj, возвращая true, если объекты совпадают в каком-либо смысле, заданном этим методом.</li>
    </ul>
    </p>
</div>
<div id="10">
    <h3>Чем отличается Comparable от Comparator?</h3>
    <p>
        В Java все коллекции, поддерживающие автоматическую сортировку, используют методы сравнения для того чтобы правильно рассортировать элементы. В качестве примера таких классов мы можем указать TreeSet, TreeMap и т.д.
        <br>Для того чтобы рассортировать элементы, класс должен реализовать интерфейсы Comparator или Comparable. Именно поэтому классы-обертки как Integer, Double и String реализуют интерфейс Comparable.
        <br><br>Интерфейс Comparable помогает сохранять естественную сортировку, тогда как Comparator позволяет сортировать элементы по разным особым шаблонам. Экземпляр компаратора обычно передается конструктору коллекции, если коллекция это поддерживает. Следует отметить, что интерфейс Comparable может быть реализован именно элементами коллекции или ключами Map, а Comparator реализуется отдельным объектом (это удобно, так как можно заготовить несколько реализаций для разных правил сортировок, не меняя при этом код элементов коллекции/ключей Map).
    </p>
</div>
<div id="11">
    <h3>Что такое сортировка по принципу Natural Order?</h3>
    <p>
    Сортировка по методу compareTo, реализованного в классах, реализующих интерфейс Comparable
    </p>
</div>
<div id="12">
    <h3>Что такое equals и hashcode?</h3>
</div>
<div id="13">
    <h3>Какие есть способы перебора всех элементов List?</h3>
</div>
<div id="14">
    <h3>Как реализован цикл foreach?</h3>
</div>
<div id="15">
    <h3>В чем разница между Iterator и ListIterator?</h3>
</div>
<div id="16">
    <h3>Как происходит удаление элементов из ArrayList?</h3>
</div>
<div id="17">
    <h3>Как происходит удаление элементов из LinkedList?</h3>
</div>
</body>

</html>